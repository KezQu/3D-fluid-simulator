#version 460 core

layout (local_size_x = 1,
		local_size_y = 1,
		local_size_z = 1) in;

const uint NONE = 0;
const uint STATIC = 1;
const uint DYNAMIC = 2;

const uint IDLE = 0;
const uint INIT = 1;
const uint SIMULATION = 2;
const uint GEN_FRAME = 3;

const uint MaxValueNeighbour = uint(0xffff);
const float cellRadius = 5;
const uint MaxCells = uint(1200 / cellRadius);
const uint HashGridSize = MaxCells * MaxCells;
const uint CellCapacity = uint(3.1415 * (4. / 3.) * pow(cellRadius, 3));
const uint MaxNeighbours = 512;

const uvec3 MeshSize = gl_NumWorkGroups * gl_WorkGroupSize;

const uint MaxParticles = MeshSize.x * 
						  MeshSize.y * 
						  MeshSize.z;
const uint index = gl_GlobalInvocationID.x + 
			(gl_GlobalInvocationID.y * MeshSize.x) + 
			(gl_GlobalInvocationID.z * MeshSize.y * MeshSize.x);

uniform mat4 model;
uniform vec3 scale;

uniform uint physicsType = NONE;
uniform uint SimulatorState = IDLE;

uniform vec3 initVelocity;

uniform float shapeRadius;
uniform float particleSpacing;
uniform float influenceKernel;
uniform float dt;
uniform float density;

struct ParticleProperties {
	vec4 velocityDFSPHfactor;
	vec4 position;
	vec4 MassDensityPressureDro_Dt;
  vec4 color;
	uint neighbours[MaxNeighbours];
};

struct TerrainProperties {
	vec4 center;
	vec4 bounds;
	mat4 model;
};

struct stateVector{
	float x;
	vec3 y;
	float z;
};

struct Flux {
	vec3 x;
	mat3 y;
	vec3 z;
};

layout(std430, binding = 0) buffer dataBuffer{
	restrict ParticleProperties particle[];
};

layout(std430, binding = 1) buffer terrainBuffer{
	restrict TerrainProperties terrain[];
};

vec3 InitDefaultShape(in uint idx, in uvec3 invocation, in uint maxParticles);

void ClearSpaceGrid(uint index_x, uint MaxParticles);
void AssignToCell(uint index_x);
void FindNeighbours(uint index_x, uint MaxParticles);

float CalculateDFSPHFactor(uint index_x);
vec3 CalculateGradPressure(uint index_x);
vec3 CalculateViscosity(uint index_x);

float CalculateMass(float density);
float CalculateDensity(uint index_x);
float CalculateAvgDensityHash(uint index_x);
float CalculateDerivDensity(uint index_x);
float CalculateAvgDerivDensity(uint index_x);

void CalculateExternalForces(uint index_x);
void SolveDensityError(uint index_x);
void SolveDivergenceError(uint index_x);
void UpdatePosition(uint index_x);

void CheckWorldBounds(uint index_x);

void UpdateTerrainOrientation(uint index_x);
void CheckCollisions(uint index_x);

vec4 ChooseColor(ParticleProperties properties);

void main(){
	if(SimulatorState == INIT){
		particle[index].velocityDFSPHfactor = vec4(initVelocity, 0);
		particle[index].position = vec4(0, 0, 0, shapeRadius);
		particle[index].MassDensityPressureDro_Dt = vec4(0);
		particle[index].color = vec4(0);
		if(physicsType != NONE){
			particle[index].position = vec4(InitDefaultShape(index, gl_GlobalInvocationID, MaxParticles) * particleSpacing * 2, 1) * shapeRadius;
		}
		if(physicsType == DYNAMIC){
			FindNeighbours(index, MaxParticles);

			particle[index].MassDensityPressureDro_Dt.x = density;
			particle[index].MassDensityPressureDro_Dt.y = CalculateDensity(index);
			particle[index].velocityDFSPHfactor.w = CalculateDFSPHFactor(index);
		}
		else if (physicsType == STATIC){
			UpdateTerrainOrientation(index);
		}
	}
	else if(SimulatorState == GEN_FRAME || SimulatorState == SIMULATION){
		if(physicsType == STATIC){
			UpdateTerrainOrientation(index);
		}
		else if(physicsType == DYNAMIC){
			particle[index].position.xyz = (model * vec4(particle[index].position.xyz * scale, 1.0)).xyz;
			CalculateExternalForces(index);

			SolveDensityError(index);

			UpdatePosition(index);

			FindNeighbours(index, MaxParticles);

			// SolveDivergenceError(index);
			particle[index].position.xyz = (inverse(model) * vec4(particle[index].position.xyz, 1.0)).xyz / scale;
		}
	}
	particle[index].color = ChooseColor(particle[index]);
}