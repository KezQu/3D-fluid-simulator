#version 460 core

layout (local_size_x = 10, local_size_y = 10, local_size_z = 10) in;

const uint NONE = 0;
const uint STATIC = 1;
const uint DYNAMIC = 2;

const uint IDLE = 0;
const uint INIT = 1;
const uint SIMULATION = 2;

const uint forcesCount = 10;
const uint KernelRadius = 1;
const uint MaxNeighbours = KernelRadius * KernelRadius * 4 * 4 * 2;


const uvec3 MeshSize = gl_NumWorkGroups * gl_WorkGroupSize;

const uint MaxParticles = MeshSize.x * 
						  MeshSize.y * 
						  MeshSize.z;
const uint index = gl_GlobalInvocationID.x + 
			(gl_GlobalInvocationID.y * MeshSize.x) + 
			(gl_GlobalInvocationID.z * MeshSize.y * MeshSize.x);


uniform uint physicsType = NONE;
uniform uint SimulatorState = IDLE;
uniform uint shapeRadius = 1;
uniform float dt = 0.01667f;

struct PhysicsProperties {
	vec4 force;
	vec4 velocity;
	vec4 position;
	vec4 VolumeDensityPressureMass;
	uint neighbours[MaxNeighbours];
};

struct Vector{
	float x;
	vec3 y;
	float z;
};

layout(std430, binding = 0) buffer dataBuffer{
	PhysicsProperties particle[];
};

vec4 InitDefaultShape(in uint idx, in uint MaxParticles);

vec4 ApplyGravitation(in vec4 particleforce, in float dt);

void FindNeighbours(in uint index, in uint MaxParticles);

Vector GenerateHydrodynamics(in uint index_i);

vec4 appliedForces[forcesCount];

void main(){
	if(SimulatorState == INIT){
		particle[index].force = vec4(0);
		particle[index].velocity = vec4(0);
		particle[index].position= vec4(0);
		particle[index].VolumeDensityPressureMass= vec4(1, 1, 0, 1);
		for(uint i = 0; i < MaxNeighbours; i++){
			particle[index].neighbours[i] = 0xffffffff;
		}

		if(physicsType != NONE){
			particle[index].position = InitDefaultShape(index, MaxParticles) * shapeRadius;
			FindNeighbours(index, MaxParticles);
		}
		Vector Q_n1 = GenerateHydrodynamics(index);
		barrier();
		particle[index].velocity.xyz = Q_n1.y / Q_n1.x;
		particle[index].VolumeDensityPressureMass.y = Q_n1.x;
	}
	else if(SimulatorState == SIMULATION && physicsType == DYNAMIC){
		for(int i = 0; i < forcesCount; i++){
			appliedForces[i] = vec4(0);
		}
		appliedForces[0] = ApplyGravitation(particle[index].force, dt);

		vec4 netForce = vec4(0);

		for(int i = 0; i < forcesCount; i++){
			netForce += appliedForces[i];
		}

//		particle[index].force = netForce;
//		if(particle[index].force.w != 0){
//			vec3 a = particle[index].force.xyz / particle[index].force.w;
//			particle[index].velocity.xyz = particle[index].velocity.xyz + a * dt;
//			particle[index].position.xyz = particle[index].position.xyz + particle[index].velocity.xyz * dt;
//		}
		Vector Q_n1 = GenerateHydrodynamics(index);
		barrier();
		particle[index].velocity.xyz = Q_n1.y / Q_n1.x;
		particle[index].VolumeDensityPressureMass.y = Q_n1.x;
	}
}