#version 460 core

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct PhysicsProperties {
	vec4 acceleration;
	vec4 position;
	vec4 velocity;
	vec4 mass;
};

layout(std140, binding = 0) buffer dataBuffer{
	PhysicsProperties particle[];
};

uniform int distributionFunctionType = -1;
uniform float grain = 1e-2;

float PI = 3.14159265358979323846264338327950288;
const uint index = gl_LocalInvocationIndex + (gl_WorkGroupID.x + 
										(gl_WorkGroupID.y * gl_NumWorkGroups.x) + 
										(gl_WorkGroupID.z * gl_NumWorkGroups.y * gl_NumWorkGroups.x));
const uint maxParticles = gl_NumWorkGroups.x * 
						gl_NumWorkGroups.y * 
						gl_NumWorkGroups.z *
						gl_WorkGroupSize.x *
						gl_WorkGroupSize.y *
						gl_WorkGroupSize.z;
vec4 Line(){
	return vec4(0.f, index - maxParticles / 2.f, 0.f, 0.f);
}
vec4 Circle(){
	const float angle = 2.f * PI / maxParticles;
	const float radius =  maxParticles / (2.f * PI);
	return vec4(
		radius * cos(angle * index),
		radius * sin(angle * index),
		0.f,
		0.f);
}
vec4 Square(){
	float meshSize = pow(maxParticles, 0.5);
	return vec4(
		floor(index / meshSize),
		mod(index, meshSize),
		0.f,
		0.f);
}
vec4 Disk(){
	vec4 candidatePosition = Square();
	if(length(candidatePosition.xyz) > sqrt(maxParticles) / 2.){
		candidatePosition.w = 1.f;
	}
	return candidatePosition;
}
vec4 Qube(){
	float meshSize = pow(maxParticles, 1 / 3.);
	return vec4(
		floor(index / meshSize), 
		mod(index, meshSize), 
		floor(index / (meshSize * meshSize)),
		0.f);
}
vec4 Sphere(){
	vec4 candidatePosition = Qube();
	if(length(candidatePosition.xyz) > pow(maxParticles, 1. / 3.) / 2.){
		candidatePosition.w = 1.f;
	}
	return candidatePosition;
}

const int LINE = 0;
const int CIRCLE = 1;
const int SQUARE = 2;
const int DISK = 3;
const int QUBE = 4;
const int SPHERE = 5;

void main(){
	vec4 positionCandidate = vec4(0);
	switch (distributionFunctionType){
	case LINE:
		positionCandidate = Line();
		break;
	case CIRCLE:
		positionCandidate = Circle();
		break;
	case SQUARE:
		positionCandidate = Square();
		break;
	case DISK:
		positionCandidate = Disk();
		break;
	case QUBE:
		positionCandidate = Qube();
		break;
	case SPHERE:
		positionCandidate = Sphere();
		break;
	default:
		break;
	}
	particle[index].position = positionCandidate * grain;
}