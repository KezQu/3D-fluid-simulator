#version 460 core

layout (local_size_x = 1,
		local_size_y = 1,
		local_size_z = 1) in;

const uvec3 MeshSize = gl_NumWorkGroups * gl_WorkGroupSize;

const uint index = gl_GlobalInvocationID.x + 
			(gl_GlobalInvocationID.y * MeshSize.x) + 
			(gl_GlobalInvocationID.z * MeshSize.y * MeshSize.x);

const uint MaxNeighbours = 512;

const uint NONE = 0;
const uint STATIC = 1;
const uint DYNAMIC = 2;

const uint WORLD_COORD = 1;
const uint EXT_FORCES = 2;
const uint GET_DEN = 3;
const uint CORR_VEL = 4;
const uint UPT_POS = 5;
const uint FIND_NEIGH = 6;
const uint UPT_PROP = 7;
const uint DIV_ERR = 8;
const uint CHECK_COLL = 9;
const uint MODEL_COORD = 10;

const float g = 9.80665;

const uint MaxParticles = MeshSize.x * 
						  MeshSize.y * 
						  MeshSize.z;

uniform uint physicsType = NONE;

uniform mat4 model;
uniform vec3 scale;
uniform float dt;



uniform vec3 initVelocity;

uniform uint physicsStage;

uniform float shapeRadius;
uniform float particleSpacing;
uniform float init_mass;

struct ParticleProperties {
	vec4 velocityDFSPHfactor;
	vec4 position;
	dvec4 MassDensityPressureDro_Dt;
  vec4 color;
	uint neighbours[MaxNeighbours];
};

layout(std430, binding = 0) buffer dataBuffer{
	restrict ParticleProperties particle[];
};

vec4 ChooseColor(ParticleProperties properties);
vec3 InitDefaultShape(in uint idx, in uvec3 invocation, in uint maxParticles);
double CalculateDensity(uint index_x);
float CalculateDFSPHFactor(uint index_x);
void UpdateTerrainOrientation(uint index_x);
void FindNeighbours(uint index_x, uint MaxParticles);
vec3 CalculateViscosity(uint index_x);
double GetInternalDensity(uint index_x);
double CalculateDerivDensity(uint index_x);
void CheckWorldBounds(uint index_x);
void CheckCollisions(uint index_x);
vec3 CalculateGradPressure(uint index_x);

void main(){
	if(physicsType == DYNAMIC){
		const float factor_x = particle[index].velocityDFSPHfactor.w;
		switch(physicsStage){
			case WORLD_COORD:
				particle[index].position.xyz = (model * vec4(particle[index].position.xyz * scale, 1.0)).xyz;
				break;
			case EXT_FORCES:
				// const double density0 = 0;//particle[index].MassDensityPressureDro_Dt.x * CalculateKernelWeight(vec3(0));
				vec3 viscosity_acceleration = CalculateViscosity(index);
				particle[index].velocityDFSPHfactor.xyz += dt * (viscosity_acceleration * 1e-3 - vec3(0, g, 0));
				break;
			case GET_DEN:
				const double density0 = GetInternalDensity(index);
				// const float factor_x = particle[index].velocityDFSPHfactor.w;

				double ro_hash = particle[index].MassDensityPressureDro_Dt.y + dt * CalculateDerivDensity(index);
				particle[index].MassDensityPressureDro_Dt.z = (ro_hash  - density0) * factor_x / pow(dt, 2);
				break;
			case CORR_VEL:
				particle[index].velocityDFSPHfactor.xyz -= dt * CalculateGradPressure(index);
				break;
			case UPT_POS:
				particle[index].position.xyz += dt * particle[index].velocityDFSPHfactor.xyz;
				break;
			case FIND_NEIGH:
				FindNeighbours(index, MaxParticles);
				break;
			case UPT_PROP:
				particle[index].MassDensityPressureDro_Dt.y = CalculateDensity(index);
				particle[index].velocityDFSPHfactor.w = CalculateDFSPHFactor(index);
				break;
			case DIV_ERR:
				particle[index].MassDensityPressureDro_Dt.y = CalculateDensity(index);
				particle[index].velocityDFSPHfactor.w = CalculateDFSPHFactor(index);
				// const float factor_x = particle[index].velocityDFSPHfactor.w;

				double d_ro = CalculateDerivDensity(index);
				particle[index].MassDensityPressureDro_Dt.z = d_ro * factor_x / dt;
				break;
			case CHECK_COLL:
				CheckWorldBounds(index);
				CheckCollisions(index);
				break;
			case MODEL_COORD:
				particle[index].position.xyz = (inverse(model) * vec4(particle[index].position.xyz, 1.0)).xyz / scale;
				break;
		}
	}else if(physicsType == STATIC){
		UpdateTerrainOrientation(index);
	}
	particle[index].color = ChooseColor(particle[index]);
}