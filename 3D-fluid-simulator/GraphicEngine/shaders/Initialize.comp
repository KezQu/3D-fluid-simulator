#version 460 core

layout (local_size_x = 5,
		local_size_y = 5,
		local_size_z = 5) in;

const uvec3 MeshSize = gl_NumWorkGroups * gl_WorkGroupSize;

const uint index = gl_GlobalInvocationID.x + 
			(gl_GlobalInvocationID.y * MeshSize.x) + 
			(gl_GlobalInvocationID.z * MeshSize.y * MeshSize.x);

const uint MaxNeighbours = 512;

const uint NONE = 0;
const uint STATIC = 1;
const uint DYNAMIC = 2;

const uint MaxParticles = MeshSize.x * 
						  MeshSize.y * 
						  MeshSize.z;

uniform uint physicsType = NONE;

uniform vec3 initVelocity;

uniform float shapeRadius;
uniform float particleSpacing;
uniform float init_mass;

struct ParticleProperties {
	vec4 velocityDFSPHfactor;
	vec4 position;
	dvec4 MassDensityPressureDro_Dt;
  vec4 color;
	uint neighbours[MaxNeighbours];
};

layout(std430, binding = 0) buffer dataBuffer{
	restrict ParticleProperties particle[];
};

vec3 InitDefaultShape(in uint idx, in uvec3 invocation, in uint maxParticles);

void FindNeighbours(uint index_x, uint MaxParticles);

double CalculateDensity(uint index_x);

void UpdateTerrainOrientation(uint index_x);

vec4 ChooseColor(ParticleProperties properties);

void main(){
	particle[index].velocityDFSPHfactor = vec4(initVelocity, 0);
	particle[index].position = vec4(0, 0, 0, shapeRadius);
	particle[index].MassDensityPressureDro_Dt = vec4(0);
	particle[index].color = vec4(0);
	if(physicsType != NONE){
		particle[index].position = vec4(InitDefaultShape(index, gl_GlobalInvocationID, MaxParticles) * particleSpacing * 2, 1) * shapeRadius;
	}
	if(physicsType == DYNAMIC){
		FindNeighbours(index, MaxParticles);

		particle[index].MassDensityPressureDro_Dt.x = init_mass;
		particle[index].MassDensityPressureDro_Dt.y = CalculateDensity(index);
		particle[index].velocityDFSPHfactor.w = CalculateDFSPHFactor(index);
	}
	else if (physicsType == STATIC){
		UpdateTerrainOrientation(index);
	}
	particle[index].color = ChooseColor(particle[index]);
}